# Task (Example)

```python find_in_sorted.py
01  """
02  Binary Search
03
04  Input:
05      arr: A sorted list of ints
06      x: A value to find
07
08  Output:
09      An index i such that arr[i] == x, or -1 if x not in arr
10
11  Example:
12      >>> find_in_sorted([3, 4, 5, 5, 5, 5, 6], 5)
13      3
14  """
15
16  def find_in_sorted(arr, x):
17      def binsearch(start, end):
18          if start == end:
19              return -1
20          mid = start + (end - start) // 2
21          if x < arr[mid]:
22              return binsearch(start, mid)
23          elif x > arr[mid]:
24              return binsearch(mid + 1, end)
25          else:
26              return mid
27
28      return binsearch(0, len(arr))
```

## Hypothesis (Example)
- The mutant changes a recursive call of the `binsearch` function from `binsearch(mid + 1, end)` to `binsearch(mid, end)`.
- The mutant is guarded by an if-condition that checks whether the search value is greater than `mid`.

I hypothesize that the mutant alters how the search space is reduced, making the function fail to find values that are present in the array. Specifically, I predict that the mutant will fail to find the search value if it is the highest value in the list, as the search value needs to be greater than `mid` in order to cover the mutant.

## Experiment (Example)
I will call `find_in_sorted` with `[1, 2, 3, 4]` as the list and `4` as the search value. I predict that the baseline will find the searched value in the list, while the mutant will fail to find the element and return `-1`.

```python
from find_in_sorted import find_in_sorted

def test_find_in_sorted():
    # Try finding the highest number at the end of the list.
    output = find_in_sorted([1, 2, 3, 4], 4)
    print(f"Output: {output}")
    assert output != -1
```

### Experiment Results (Example)

### Running Experiment on Baseline
```
Output: 3
```

### Running Experiment on Mutant
```
Output: 3
```

## Conclusion (Example)
The experiment shows that both the baseline and the mutant correctly find the `4` at the end of the list, returning the correct index `3`. This contradicts my prediction.

Key conclusions:
- Both baseline and mutant are able to find `4` in `[1, 2, 3, 4]`.

## Hypothesis (Example)
In the previous experiment, I tested whether an existing element can be found in the list. Now, I will check if searching an element that is not contained in the input list will result in a difference. I hypothesize that the mutant will give an incorrect output when a value greater than the highest value in the list is searched.

## Experiment (Example)
I will call `find_in_sorted` with `[1, 2, 3, 4]` as the list and `5` as the search value. I predict that the baseline will return `-1` as the value is not part of the list, while the mutant will return a different output.

```python
from find_in_sorted import find_in_sorted

def test_find_in_sorted():
    # Try finding a number higher than the highest number in the list.
    output = find_in_sorted([1, 2, 3, 4], 5)
    print(f"Output: {output}")
    assert output == -1, f"Expected -1, got {output}"
```

### Experiment Results (Example)

### Running Experiment on Baseline
```
Output: -1
```

### Running Experiment on Mutant
```
Traceback (most recent call last):
  File "test.py", line 8, in <module>
    test_find_in_sorted()
  File "test.py", line 5, in test_find_in_sorted
    output = find_in_sorted([1, 2, 3, 4], 5)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "find_in_sorted.py", line 28, in find_in_sorted
    return binsearch(0, len(arr))
           ^^^^^^^^^^^^^^^^^^^^^^
  File "find_in_sorted.py", line 24, in binsearch
    return binsearch(mid, end)
           ^^^^^^^^^^^^^^^^^^^
  [Previous line repeated 988 more times]
  File "find_in_sorted.py", line 17, in binsearch
    def binsearch(start, end):

RecursionError: maximum recursion depth exceeded
```
The experiment exited with exit code 1.

## Conclusion (Example)
The baseline returned `-1` as predicted, while the mutant results in a `RecursionError`. This confirms my hypothesis.

Key conclusions:
- The mutant raises an error when searching for `5` in `[1, 2, 3, 4]`.
- The baseline returns `-1` (the correct output) when searching for `5` in `[1, 2, 3, 4]`.

Since I have identified consistent behavior in the mutant that can be exploited, I am now ready to create a test that will kill the mutant.

## Test (Example)

The test will call `find_in_sorted` with `[1, 2, 3, 4]` as the list and `5` as the searched value. As demonstrated before, this should lead to a `RecursionError` for the mutant, while the baseline returns `-1`.

```python
from find_in_sorted import find_in_sorted

def test_find_in_sorted_mutant_killing():
    """
    Test the find_in_sorted function using a value greater than
    the highest in the array. The mutant will enter an infinite
    recursion, while the baseline will return -1.
    """
    output = find_in_sorted([1, 2, 3, 4], 5)
    assert output == -1, f"Expected -1, got {output}"
```

# Test Results (Example)

## Running Test on Baseline

```

```

## Running Test on Mutant

```
Traceback (most recent call last):
  File "test.py", line 11, in <module>
    test_find_in_sorted_mutant_killing()
  File "test.py", line 9, in test_find_in_sorted_mutant_killing
    output = find_in_sorted([1, 2, 3, 4], 5)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "find_in_sorted.py", line 28, in find_in_sorted
    return binsearch(0, len(arr))
           ^^^^^^^^^^^^^^^^^^^^^^
  File "find_in_sorted.py", line 24, in binsearch
    return binsearch(mid, end)
           ^^^^^^^^^^^^^^^^^^^
  File "find_in_sorted.py", line 24, in binsearch
    return binsearch(mid, end)
           ^^^^^^^^^^^^^^^^^^^
  File "find_in_sorted.py", line 24, in binsearch
    return binsearch(mid, end)
           ^^^^^^^^^^^^^^^^^^^
  [Previous line repeated 986 more times]
  File "find_in_sorted.py", line 17, in binsearch
    def binsearch(start, end):

RecursionError: maximum recursion depth exceeded
```
The test exited with exit code 1.
